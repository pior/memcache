The goal of this project is to implement a memcache client in Go.

Source material:
- Use everything in the references directory to know how to implement the client.
- The files directly in the references directory are the best source of information.
- The references directory also contains implementations that can be used as a guide.

Features:
- The client must be thread-safe.
- Only support the meta protocol, not the text protocol.
- Support for commands pipelining.
- Support for connection pooling, with a preference for the connection that has the least number of requests in flight.
- Support adding an optional circuit breaker on connections.
- Support using multiple servers, with a plugable routing strategy, defaulting to consistent hashing.
- Efficient handling of responses.
- Consider using opaque flags for tracking requests.
- Consider not using the noreply flag, to avoid complexity in response and error handling.

Actions:
- Implement the client as a single package, without sub-packages.
- Implement the client as a composition of a connection pool, and a protocol handler, such that the protocol handler can be used with a custom connection pool if needed.
- Write code that is easy to unit-test, especially for the protocol, the pipelining and the connection pool components.
- Write unit-tests where appropriate
- Write integration tests that use a real memcached server, provided by the existing docker-compose file.
- Write benchmark tests to measure performance.
- Run the benchmarks regularly and accumulate the results in benchmarks-results.md, with a summary of the current state of the implementation.
- Write a CLI tool that uses the client with the testing server and pushes the implementation to its limits.
- Write fuzzy tests where relevant to ensure robustness.
- Write a README.md file that explains what the project is about, the exact features implemented and scoped out, and how to use the client.

API:
- The main API should be able to efficiently handle multiple commands in a single call, but also stay simple and intuitive to use for common use cases.

Other decisions about code:
- Use the latest Go version, no need for compatibility with older versions.
- Prefer a simple and efficient design over extensive features.
- Only uses the standard library

Code Style:
- Follow Go's standard formatting and naming conventions.
- Use concise and clear variable names.
- Do not add comments unless necessary for understanding the code.
