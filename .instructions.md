The goal of this project is to implement a memcache client in Go.

Source material:
- Use everything in the references directory to know how to implement the client.
- The files directly in the references directory are the best source of information.
- The references directory also contains implementations that can be used as a guide.

Features:
- The client must be thread-safe.
- Only support the meta protocol, not the text protocol.
- Support for commands pipelining.
- Support for connection pooling, with a preference for the connection that has the least number of requests in flight.
- Support adding an optional circuit breaker on connections.
- Support using multiple servers, with a plugable routing strategy, defaulting to consistent hashing.
- Efficient handling of responses.
- Consider using opaque flags for tracking requests.
- Consider not using the noreply flag, to avoid complexity in response and error handling.

Actions:
- Implement the client as a single package, without sub-packages.
- Implement the client as a composition of a connection pool, and a protocol handler, such that the protocol handler can be used with a custom connection pool if needed.
- Write code that is easy to unit-test, especially for the protocol, the pipelining and the connection pool components.
- Write unit-tests where appropriate
- Write integration tests that use a real memcached server, provided by the existing docker-compose file.
- Write benchmark tests to measure performance.
- Run the benchmarks regularly and accumulate the results in benchmarks-results.md, with a summary of the current state of the implementation.
- Write fuzzy tests where relevant to ensure robustness.
- Write a README.md file that explains what the project is about, the exact features implemented and scoped out, and how to use the client.
- Write a CLI tool named memcache-bench, that uses the client with a testing server and perform benchmarks on the main operations successively, measuring their performance.


API:
- The main API should be a single methods like `Do(ctx context.Context, cmd []*Command) ([]*Response, error)`
- `Command` is a struct that represents a memcache command and `Response` is a struct that represents the response
- `Command` exposes the concepts of the meta protocol that can be controlled by the user, but not the concepts that are fully controlled by the client, like the Opaque field.


Other decisions about code:
- Use the latest Go version, no need for compatibility with older versions.
- Prefer a simple and efficient design over extensive features.
- Only uses the standard library
- Write individual test files, like protocol_test.go, protocol_bench_test.go, and protocol_fuzz_test.go for protocol.go.

Code Style:
- Follow Go's standard formatting and naming conventions.
- Use concise and clear variable names.
- Do not add comments unless necessary for understanding the code.
- In tests, use the new form of loop: `for b.Loop() {}` or `for t.Loop() {}`.