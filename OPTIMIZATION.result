# Optimization #6: Stack-allocated CRLF buffer in reader

## Implementation
- Replace `crlf := make([]byte, 2)` with `var crlf [2]byte`
- Use direct byte comparison instead of `bytes.Equal()`
- Stack-allocated array avoids heap allocation for CRLF verification

## Changes
- Changed from slice allocation to stack-allocated array
- Direct comparison `crlf[0] != '\r' || crlf[1] != '\n'`
- Removed bytes import

## Benchmark Results

### Before (current main with buffered writing merged):
```
BenchmarkClient_Get-8                          567664    1998 ns/op    4767 B/op    13 allocs/op
BenchmarkClient_Get_Miss-8                     588818    1993 ns/op    4765 B/op    13 allocs/op
BenchmarkClient_Set-8                          583712    2007 ns/op    4778 B/op    13 allocs/op
BenchmarkClient_Set_WithTTL-8                  558322    2046 ns/op    4805 B/op    14 allocs/op
BenchmarkClient_Set_LargeValue-8               107284   13091 ns/op   34753 B/op    13 allocs/op
BenchmarkClient_Add-8                          586491    2056 ns/op    4802 B/op    14 allocs/op
BenchmarkClient_Delete-8                       608958    2030 ns/op    4741 B/op    12 allocs/op
BenchmarkClient_Increment-8                    544855    2063 ns/op    4870 B/op    13 allocs/op
BenchmarkClient_Increment_WithTTL-8            539032    2145 ns/op    5063 B/op    14 allocs/op
BenchmarkClient_Increment_NegativeDelta-8      548280    2070 ns/op    4902 B/op    13 allocs/op
BenchmarkClient_MixedOperations-8              570344    2047 ns/op    4774 B/op    12 allocs/op
```

### After (with stack-allocated CRLF array):
```
BenchmarkClient_Get-8                          579868    1994 ns/op    4766 B/op    13 allocs/op
BenchmarkClient_Get_Miss-8                     589986    1988 ns/op    4765 B/op    13 allocs/op
BenchmarkClient_Set-8                          587956    1988 ns/op    4778 B/op    13 allocs/op
BenchmarkClient_Set_WithTTL-8                  569271    2032 ns/op    4804 B/op    14 allocs/op
BenchmarkClient_Set_LargeValue-8               181906   13607 ns/op   40144 B/op    13 allocs/op
BenchmarkClient_Add-8                          585759    2038 ns/op    4802 B/op    14 allocs/op
BenchmarkClient_Delete-8                       576240    2083 ns/op    4743 B/op    12 allocs/op
BenchmarkClient_Increment-8                    531513    2096 ns/op    4872 B/op    13 allocs/op
BenchmarkClient_Increment_WithTTL-8            511107    2202 ns/op    5066 B/op    14 allocs/op
BenchmarkClient_Increment_NegativeDelta-8      529603    2098 ns/op    4904 B/op    13 allocs/op
BenchmarkClient_MixedOperations-8              535214    2089 ns/op    4777 B/op    12 allocs/op
```

## Analysis
- **Allocations**: No change (12-14 allocs/op)
- **Memory**:
  - Most operations: -1 byte (negligible)
  - **LargeValue: +5.4KB regression** (40144 vs 34753 B/op, +15.5%)
- **Latency**: Mixed results, mostly within noise

## Why This Doesn't Work Well
The [2]byte array should stay on the stack for CRLF verification, but the significant memory regression on LargeValue suggests:
1. Possible escape analysis issues in some code paths
2. The original 2-byte slice allocation was negligible compared to large value data
3. Change in memory layout or alignment affecting measurements

The lack of allocation reduction indicates the original `make([]byte, 2)` was already optimized or the compiler was already stack-allocating it.

## Conclusion
This optimization provides **no meaningful benefit** and shows a memory regression on large values.

**Recommendation**: ‚ùå **REJECT** - No allocation reduction, memory regression on large values. The 2-byte CRLF allocation is not a bottleneck worth optimizing.
